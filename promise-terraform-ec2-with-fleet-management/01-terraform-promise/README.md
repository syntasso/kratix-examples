# Terraform Promise

In this README we will explain how you can create and customise a Promise by
bootstraping it from a Terraform module.


## Prerequisites

To complete this tutorial you will need access to:

- Kubernetes Cluster: Any provider can be used, for simplicity of handling
Docker images using a local cluster like KinD or Minikube is preferable as you
can load the images directly into the cluster.

- AWS (or other cloud provider) account: This is required to create the
  terraform resources

- The following CLIs:

  - **kubectl**: For interacting with the Kubernetes cluster
  
  - [**kratix**](https://github.com/syntasso/kratix-cli/releases): For
  bootstrapping the Promise

  - **docker**: For building the Docker image

## Introduction
Terraform is a popular Infrastructure as Code (IaC) tool that allows you to
define and provision infrastructure using declarative configuration files. In
lots of existing platforms, Terraform is used to manage the underlying
infrastructure, and is normally either:

- Maintained centrally by a platform team
  - Developers raise tickets or PRs to request changes
- Used by developers to provision their own infrastructure
  - Developers write, run and maintain Terraform code to manage their own
  resources

Both of these approaches have their own challenges, such as:

- Manual based workflows that centralise Terraform can lead to bottlenecks and
delays in provisioning resources.

- Developers managing their own Terraform code can lead to inconsistencies,
duplication, and a lack of governance, as well as a high cognitive load

Kratix tries to solve this by making it easy to expose anything you want to
offer on your platform as a self-serve API. Once its being consumed by Kratix,
it can then be managed as a fleet of resources, allowing you to apply governance
and policies to the resources, as well as providing a consistent user experience
all while keeping the cost of managing the platform low.

In this example we will show how easy it is to achieve a self-serve, fleet
management offering using Kratix. We will use the
[terraform-aws-ec2-instance](https://github.com/terraform-aws-modules/terraform-aws-ec2-instance)
module as an example, however you may use any module you wish and follow the
steps with modifications to fit your module.

## Promise

A [Promise](https://docs.kratix.io/main/reference/promises/intro) in Kratix consists of 4 componenets:

- API: Where you define what information you want from a user when they make a
request

- Workflows: A series of Docker contains that run when a user makes, updates,
delete a request to the Promise (as well as at a regular cadense to do drift
detection)

- Dependencies: Anything that needs to be resolved before the Promise can be
accepted requests.

- Destination Selectors: Where the Promise will schedule any of its declarative
workloads.

In this tutorial we will create a simple Promise that focuses on just using the
the API and Workflows components. If you are curious on how to create a Promise
with Dependencies and Destination Selectors, please refer to the main
[workshop](https://docs.kratix.io/workshop/intro)


### Initialise the Promise

The Kratix CLI provides an `init` command to quickly create a Promise from a
Terraform module. It will a Promise with:
- An API thats equivalent to the Terraform Module vars file
- A Workflow that will read the API inputs and use that to generate the
corresponding Terraform code to create the resources.

This provides a strong starting point for your Promise, and you can then
customise it to fit your needs.

To initalise the Promise, run the following command in the directory where you
want to create the Promise:

```bash
kratix init tf-module-promise vm \
  --split --group example.com \
  --kind VM \
  --version v1 \
  --dir . \
  --module-version v6.0.2 \
  --module-source https://github.com/terraform-aws-modules/terraform-aws-ec2-instance
```

You might see a series of **warnings** about the API not being fully defined with
defaults. This is expected as the Terraform module supports a level of complex
defaulting the Kratix API does not support yet. The API will still work, it just
wont automatically declare some of the defaults for you.

If you inspect the `promise.yaml` that got created, you will see that it has:
- An API consisting of the equivalent of the Terraform module's
  variables, with some defaults set.
- A Workflow that will runs a single container, this container will generate the
  terraform module instance with all of the users inputs.

This is a great starting point for your Promise, if you were choosing to have
all of your terraform reconciled via a Git Repository, you could simply take
this Promise and add a Destination Selector to it, and it would start
schedule the terraform generated by the Workflow to the Git repository everytime
a user makes a request to the Promise.

For simplicity in this demo we aren't going to do that, instead we will run
terraform apply directly in the Workflow container.

### Terraform Apply
Lets update the promise to run `terraform apply` in the Workflow container.

Add the follow container to run after the  `terraform-generate` container thats
located at the bottom of the `promise.yaml` file (it should be after the
`terraform-generate` container):

```yaml
- name: terraform-apply
  image: hashicorp/terraform:1.8.3
  command:
    - /bin/sh
    - -c
    - |
      set -euo pipefail
      echo "Reading inputs from /kratix/input/object.yaml"
      NAME=$(awk '/^[[:space:]]*name:/ { print $2; exit }' /kratix/input/object.yaml | tr -d '"')
      NAMESPACE=$(awk '/^[[:space:]]*namespace:/ { print $2; exit }' /kratix/input/object.yaml | tr -d '"')


      echo "Setting up Terraform working directory"
      mkdir -p /tmp/tf-apply/
      cd /tmp/tf-apply/

      echo "Copying Terraform files from /kratix/output/"
      cp -r /kratix/output/* .

      echo "Creating backend.tf file for Terraform state management"
      cat <<EOF > backend.tf
      terraform {
        backend "s3" {
          bucket = "kratix-examples-TODO-ORG-NAME"
          key    = "${NAMESPACE}-${NAME}-terraform.tfstate"
          region = "${AWS_REGION}"
        }
      }
      EOF

      echo "Initialising Terraform"
      terraform init
      echo "Applying Terraform configuration"
      terraform apply -auto-approve
  env:
    - name: AWS_ACCESS_KEY_ID
      valueFrom:
        secretKeyRef:
          name: aws-creds
          key: access_key_id
    - name: AWS_SECRET_ACCESS_KEY
      valueFrom:
        secretKeyRef:
          name: aws-creds
          key: secret_access_key
    - name: AWS_REGION
      valueFrom:
        secretKeyRef:
          name: aws-creds
          key: region
```

Ensure you've: 
- indented it correctly, it should be at the same level as the
`terraform-generate` container.
- Replaced the `TODO` bucket name in the `backend.tf` backend provider to a valid S3 bucket name
  that you have access to and exists. This bucket will be used to store the Terraform state.
- If you plan to use a different cloud provider, you will need to change the
environment variables to match the credentials and region for that provider.

The last thing to do before we can run the Promise is to ensure we have created
the `aws-creds` secret in the cluster. To create the secret (in this example
AWS), run:

```bash
kubectl create secret generic aws-creds \
  --from-literal=access_key_id=$AWS_ACCESS_KEY_ID \
  --from-literal=secret_access_key=$AWS_SECRET_ACCESS_KEY \
  --from-literal=region=$AWS_REGION
```

### Testing the Promise
Now that we have the Promise set up, we can test it by creating a request to
the Promise. When we ran `kratix init` it created a `example-request.yaml` that
contains a sample request to the Promise. Update this file to set a subnet (the
only required field) to a valid subnet in your AWS account, e.g:
```yaml
apiVersion: example.com/v1
kind: VM
metadata:
  name: example-vm
spec:
  subnet_id: subnet-123456789abcdefghi
```

and then run:

```bash
kubectl apply -f example-request.yaml
```

You should see this kick off th workload Pod that will run the
`terraform-generate` and `terraform-apply` containers. You can check the
status of the Pod by running:

```bash
kubectl get pods -l kratix.io/promise-name=vm -w
```

You can inspect the logs for your `terraform-apply` container by running (it
might take some time before the logs can be seen, as the previous init
containers need to complete first):

```bash
kubectl logs -l kratix.io/promise-name=vm -c terraform-apply
```

Eventually the Pod will complete and you should see the EC2 instance
created in your AWS account. 

You've now successfully:
- ✅ Created a Promise from a Terraform module
- ✅ Customised the Promise to run `terraform apply` in the Workflow container
- ✅ Tested the Promise by creating a request to it and seeing the EC2 instance
  created in your AWS account

This is an excellent starting point for creating a self-serve API for providing
infrastructure resources to your users. You can further enhance the Promise by
adding more (or less!) API fields, integrating extra business logic (e.g. manual
approvals, notifications or billing) and support deletion. Lets tackle the last
part now.

### Enhancing for deletion

To enhance the Promise to support deletion, we need to add a new Workflow that
will run when a user deletes a request to the Promise. This Workflow will
essentially run `terraform destroy` to remove the resources created by the
Promise. Update the `promise.yaml` file to add the following. It should sit as a
peer to the `.spec.workflows.resource.configure` Workflow, so it should be at
the same level of indentation

```yaml
      delete:
        - apiVersion: platform.kratix.io/v1alpha1
          kind: Pipeline
          metadata:
            name: instance-delete
          spec:
            containers:
            - name: terraform-destroy
              image: hashicorp/terraform:1.8.3
              command:
                - /bin/sh
                - -c
                - |
                  set -euo pipefail
                  mkdir /tmp/tf-delete/
                  cd /tmp/tf-delete/

                  NAME=$(awk '/^[[:space:]]*name:/ { print $2; exit }' /kratix/input/object.yaml | tr -d '"')
                  NAMESPACE=$(awk '/^[[:space:]]*namespace:/ { print $2; exit }' /kratix/input/object.yaml | tr -d '"')

                  cat <<EOF > backend.tf
                  terraform {
                    backend "s3" {
                      bucket = "kratix-examples-jake"
                      key    = "envs/${NAMESPACE}-${NAME}-terraform.tfstate"
                      region = "${AWS_REGION}"
                    }
                  }
                  EOF

                  terraform init
                  terraform destroy -auto-approve
              env:
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: aws-creds
                      key: access_key_id
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: aws-creds
                      key: secret_access_key
                - name: AWS_REGION
                  valueFrom:
                    secretKeyRef:
                      name: aws-creds
                      key: region
```


Apply the updated Promise:

```bash
kubectl apply -f promise.yaml
```
Now you can test the deletion by running:

```bash
kubectl delete -f example-request.yaml
```

This will trigger the `instance-delete` Workflow, which will run the
`terraform-destroy` container to remove the resources created by the Promise.

You can check the status of the Pod by running:

```bash
kubectl get pods -l kratix.io/promise-name=vm -w
```

You can inspect the logs for your `terraform-destroy` container by running:

```bash
kubectl logs -l kratix.io/promise-name=vm -l kratix.io/workflow-action=delete -c terraform-destroy
```

You should see the EC2 instance being destroyed in your AWS account.
